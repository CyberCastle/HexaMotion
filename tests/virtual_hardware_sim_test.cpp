/**
 * @file virtual_hardware_sim_test.cpp
 * @brief Test to simulate virtual hardware interfaces with HexaMotion system.
 *
 * This test implements custom interface implementations that simulate virtual
 * hardware and visualize the servo angles generated by the HexaMotion locomotion
 * system during a tripod gait. The test provides detailed visualization of:
 * 1. Joint angles for each leg (coxa, femur, tibia) in degrees
 * 2. Angular velocities and speeds
 * 3. Movement progression over time
 * 4. Virtual hardware behavior simulation
 *
 * IMPORTANT NOTE ABOUT ANGLE UNITS:
 * This test captures angles through the IServoInterface, where angles arrive
 * already converted to DEGREES by LocomotionSystem::setLegJointAngles().
 * This is different from tripod_walk_visualization_test.cpp which reads angles
 * directly from Leg objects (in radians) and converts them to degrees for display.
 * Both tests should show identical angle values when executed correctly.
 *
 * The test uses:
 * - VisualizationIMU: Virtual IMU implementation for stable orientation
 * - VisualizationFSR: Virtual FSR implementation for ground contact simulation
 * - AngleVisualizationServo: Virtual servo interface that captures and displays angles
 *
 * @author HexaMotion Team
 * @version 1.0
 * @date 2025
 */

#include "../src/body_pose_config_factory.h"
#include "../src/gait_config_factory.h"
#include "../src/locomotion_system.h"
#include "robot_model.h"
#include "test_stubs.h"
#include <cassert>
#include <chrono>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <thread>
#include <vector>

// Test configuration
constexpr double TEST_VELOCITY = 40.0;   // mm/s, moderate speed for clear observation
constexpr int VISUALIZATION_STEPS = 150; // Steps to run the visualization
constexpr int ANGLE_HISTORY_SIZE = 200;  // Number of angle measurements to store

/**
 * @brief Custom IMU interface for visualization that provides stable orientation data
 */
class VisualizationIMU : public IIMUInterface {
  private:
    double roll_ = 0.0;
    double pitch_ = 0.0;
    double yaw_ = 0.0;
    IMUMode current_mode_ = IMU_MODE_RAW_DATA;
    bool has_absolute_ = true;
    int update_count_ = 0;

  public:
    bool initialize() override {
        std::cout << "VisualizationIMU: Initialized with absolute positioning enabled" << std::endl;
        return true;
    }

    IMUData readIMU() override {
        IMUData data{};
        data.roll = roll_;
        data.pitch = pitch_;
        data.yaw = yaw_;
        data.accel_x = 0.0f;
        data.accel_y = 0.0f;
        data.accel_z = 9.81f;
        data.gyro_x = 0.0f;
        data.gyro_y = 0.0f;
        data.gyro_z = 0.0f;
        data.is_valid = true;
        data.mode = current_mode_;
        data.has_absolute_capability = has_absolute_;

        if (has_absolute_) {
            data.absolute_data.absolute_roll = roll_;
            data.absolute_data.absolute_pitch = pitch_;
            data.absolute_data.absolute_yaw = yaw_;
            data.absolute_data.linear_accel_x = 0.0f;
            data.absolute_data.linear_accel_y = 0.0f;
            data.absolute_data.linear_accel_z = 0.0f;
            data.absolute_data.quaternion_w = 1.0f;
            data.absolute_data.quaternion_x = 0.0f;
            data.absolute_data.quaternion_y = 0.0f;
            data.absolute_data.quaternion_z = 0.0f;
            data.absolute_data.absolute_orientation_valid = true;
            data.absolute_data.linear_acceleration_valid = true;
            data.absolute_data.quaternion_valid = true;
            data.absolute_data.calibration_status = 3;
            data.absolute_data.system_status = 5;
            data.absolute_data.self_test_result = 0x0F;
        }

        return data;
    }

    bool calibrate() override { return true; }
    bool isConnected() override { return true; }
    bool setIMUMode(IMUMode mode) override {
        current_mode_ = mode;
        return true;
    }
    IMUMode getIMUMode() const override { return current_mode_; }
    bool hasAbsolutePositioning() const override { return has_absolute_; }
    bool getCalibrationStatus(uint8_t *system, uint8_t *gyro, uint8_t *accel, uint8_t *mag) override {
        if (system)
            *system = 3;
        if (gyro)
            *gyro = 3;
        if (accel)
            *accel = 3;
        if (mag)
            *mag = 3;
        return true;
    }
    bool runSelfTest() override { return true; }
    bool resetOrientation() override { return true; }
    bool update() override {
        update_count_++;
        return true;
    }

    // Add slight terrain simulation
    void simulateTerrainTilt(int step) {
        // Simulate gentle terrain variations
        double terrain_freq = 0.02;
        roll_ = 2.0 * sin(step * terrain_freq) * M_PI / 180.0;        // Â±2 degrees
        pitch_ = 1.5 * cos(step * terrain_freq * 1.3) * M_PI / 180.0; // Â±1.5 degrees
    }
};

/**
 * @brief Custom FSR interface for visualization with realistic ground contact simulation
 */
class VisualizationFSR : public IFSRInterface {
  private:
    FSRData test_data_[NUM_LEGS];
    int update_count_ = 0;

  public:
    VisualizationFSR() {
        for (int i = 0; i < NUM_LEGS; i++) {
            test_data_[i] = FSRData{3.0f, true, 0.0f}; // Start with ground contact
        }
        std::cout << "VisualizationFSR: Initialized with all legs in contact" << std::endl;
    }

    bool initialize() override { return true; }

    FSRData readFSR(int leg) override {
        if (leg >= 0 && leg < NUM_LEGS) {
            return test_data_[leg];
        }
        return FSRData{0.0f, false, 0.0f};
    }

    bool calibrateFSR(int) override { return true; }

    double getRawReading(int leg) override {
        if (leg >= 0 && leg < NUM_LEGS) {
            return test_data_[leg].pressure;
        }
        return 0.0f;
    }

    bool update() override {
        update_count_++;
        // Simulate realistic pressure variations during walking
        for (int i = 0; i < NUM_LEGS; i++) {
            if (test_data_[i].in_contact) {
                // Add slight pressure variations for legs in contact
                test_data_[i].pressure = 3.0f + 0.5f * sin(update_count_ * 0.1 + i);
            }
        }
        return true;
    }

    // Simulate leg lifting and touchdown for gait visualization
    void simulateGaitContact(int leg, bool in_contact) {
        if (leg >= 0 && leg < NUM_LEGS) {
            test_data_[leg].in_contact = in_contact;
            test_data_[leg].pressure = in_contact ? 3.5f : 0.1f;
        }
    }
};

/**
 * @brief Servo angle data structure for storing angle history
 */
struct ServoAngleRecord {
    int step;
    int leg;
    int joint;
    double angle_degrees;
    double speed;
    double target_angle_degrees;
    std::chrono::steady_clock::time_point timestamp;
};

/**
 * @brief Custom servo interface that captures and visualizes all angle commands
 */
class AngleVisualizationServo : public IServoInterface {
  private:
    double current_angles_[NUM_LEGS][3]; // [leg][joint]
    double target_angles_[NUM_LEGS][3];  // [leg][joint]
    double speeds_[NUM_LEGS][3];         // [leg][joint]
    bool torque_enabled_[NUM_LEGS][3];   // [leg][joint]
    std::vector<ServoAngleRecord> angle_history_;
    int current_step_ = 0;

    const char *joint_names_[3] = {"Coxa", "Femur", "Tibia"};

  public:
    AngleVisualizationServo() {
        // Initialize with neutral standing positions
        // NOTE: These initial values are in RADIANS for internal consistency with the robot model,
        // but setJointAngleAndSpeed() will receive angles already converted to DEGREES by LocomotionSystem
        for (int leg = 0; leg < NUM_LEGS; leg++) {
            current_angles_[leg][0] = 0.0;  // Coxa neutral (will be overwritten by degree values from servo commands)
            current_angles_[leg][1] = -35;  // Femur ~23 degrees (corrected to degrees for servo interface consistency)
            current_angles_[leg][2] = 35.0; // Tibia ~-57 degrees (corrected to degrees for servo interface consistency)

            for (int joint = 0; joint < 3; joint++) {
                target_angles_[leg][joint] = current_angles_[leg][joint];
                speeds_[leg][joint] = 1.0;
                torque_enabled_[leg][joint] = true;
            }
        }
        angle_history_.reserve(ANGLE_HISTORY_SIZE * NUM_LEGS * 3);
        std::cout << "AngleVisualizationServo: Initialized with neutral standing angles (in degrees)" << std::endl;
    }

    bool initialize() override {
        std::cout << "AngleVisualizationServo: Hardware interface initialized" << std::endl;
        return true;
    }

    bool hasBlockingStatusFlags(int leg, int joint) override {
        // No blocking flags for visualization
        return false;
    }

    bool setJointAngleAndSpeed(int leg, int joint, double angle, double speed) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            // Store previous angle for comparison
            double prev_angle = target_angles_[leg][joint];

            // Update target angle and speed
            // NOTE: The 'angle' parameter arrives already converted to DEGREES by LocomotionSystem::setLegJointAngles()
            // which applies: servo_angle = joint_angle_radians * params.angle_sign_* * RADIANS_TO_DEGREES_FACTOR
            target_angles_[leg][joint] = angle;
            speeds_[leg][joint] = speed;

            // Simulate servo movement towards target (with some smoothing)
            double diff = angle - current_angles_[leg][joint];
            double movement_rate = 0.3 * speed; // Adjust movement rate based on speed
            movement_rate = std::max(0.1, std::min(1.0, movement_rate));
            current_angles_[leg][joint] += diff * movement_rate;

            // Record this angle command
            ServoAngleRecord record;
            record.step = current_step_;
            record.leg = leg;
            record.joint = joint;
            record.angle_degrees = angle; // Already in degrees
            record.speed = speed;
            record.target_angle_degrees = angle; // Already in degrees
            record.timestamp = std::chrono::steady_clock::now();

            angle_history_.push_back(record);

            return true;
        }
        return false;
    }

    double getJointAngle(int leg, int joint) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            // Return current simulated position with small noise
            return current_angles_[leg][joint] + (rand() % 100 - 50) * 0.001;
        }
        return 0.0;
    }

    bool isJointMoving(int leg, int joint) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            // Consider joint moving if difference between current and target is significant
            return std::abs(target_angles_[leg][joint] - current_angles_[leg][joint]) > 0.02;
        }
        return false;
    }

    bool enableTorque(int leg, int joint, bool enable) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            torque_enabled_[leg][joint] = enable;
            return true;
        }
        return false;
    }

    // Visualization methods
    void updateStep(int step) {
        current_step_ = step;
    }

    void printCurrentAngles() {
        std::cout << "\n=== CURRENT SERVO ANGLES ===" << std::endl;
        std::cout << std::left << std::setw(6) << "Leg"
                  << std::setw(12) << "Coxa (Â°)"
                  << std::setw(12) << "Femur (Â°)"
                  << std::setw(12) << "Tibia (Â°)"
                  << std::setw(12) << "Moving?" << std::endl;
        std::cout << "---------------------------------------------------------------" << std::endl;

        for (int leg = 0; leg < NUM_LEGS; leg++) {
            std::cout << std::fixed << std::setprecision(2);
            std::cout << std::left << std::setw(6) << ("L" + std::to_string(leg + 1));

            for (int joint = 0; joint < 3; joint++) {
                std::cout << std::setw(12) << current_angles_[leg][joint];
            }

            // Check if any joint is moving
            bool any_moving = false;
            for (int joint = 0; joint < 3; joint++) {
                if (isJointMoving(leg, joint)) {
                    any_moving = true;
                    break;
                }
            }
            std::cout << std::setw(12) << (any_moving ? "YES" : "NO") << std::endl;
        }
        std::cout << "---------------------------------------------------------------\n"
                  << std::endl;
    }

    void generateAngleReport() const {
        std::ofstream report("hexamotion_angle_report.txt");
        if (!report.is_open()) {
            std::cerr << "Warning: Could not create angle report file" << std::endl;
            return;
        }

        report << "HexaMotion Servo Angle Visualization Report\n";
        report << "==========================================\n\n";

        report << "Test Configuration:\n";
        report << "- Velocity: " << TEST_VELOCITY << " mm/s\n";
        report << "- Total Steps: " << current_step_ << "\n";
        report << "- Total Angle Commands: " << angle_history_.size() << "\n\n";

        report << "Final Servo Positions:\n";
        for (int leg = 0; leg < NUM_LEGS; leg++) {
            report << "Leg " << (leg + 1) << ": ";
            for (int joint = 0; joint < 3; joint++) {
                report << joint_names_[joint] << "="
                       << std::fixed << std::setprecision(2)
                       << current_angles_[leg][joint] << "Â° ";
            }
            report << "\n";
        }

        report << "\nComplete Angle Command History:\n";
        report << "Step\tLeg\tJoint\tAngle(Â°)\tSpeed\n";
        for (const auto &record : angle_history_) {
            report << record.step << "\t"
                   << (record.leg + 1) << "\t"
                   << joint_names_[record.joint] << "\t"
                   << std::fixed << std::setprecision(2) << record.target_angle_degrees << "\t"
                   << record.speed << "\n";
        }

        report.close();
        std::cout << "Angle report saved to: hexamotion_angle_report.txt" << std::endl;
    }

    size_t getAngleHistorySize() const { return angle_history_.size(); }

    // Visualize servo angles purely from hardware interface data
    void printServoVisualization(int step) {
        std::cout << "\n=== SERVO ANGLES VISUALIZATION (Step " << step << ") ===" << std::endl;
        std::cout << std::left << std::setw(8) << "Leg"
                  << std::setw(12) << "Coxa (Â°)"
                  << std::setw(12) << "Femur (Â°)"
                  << std::setw(12) << "Tibia (Â°)"
                  << std::setw(12) << "Moving?" << std::endl;
        std::cout << "---------------------------------------------------------------" << std::endl;

        for (int leg = 0; leg < NUM_LEGS; leg++) {
            std::cout << std::fixed << std::setprecision(2);
            std::cout << std::left << std::setw(8) << ("Leg " + std::to_string(leg + 1));

            // Show target angles (what HexaMotion is commanding)
            // NOTE: These angles are already in degrees as received from LocomotionSystem::setLegJointAngles()
            // which converts from radians to degrees using RADIANS_TO_DEGREES_FACTOR before sending to servo interface
            for (int joint = 0; joint < 3; joint++) {
                std::cout << std::setw(12) << target_angles_[leg][joint];
            }

            // Check if any joint is moving
            bool any_moving = false;
            for (int joint = 0; joint < 3; joint++) {
                if (isJointMoving(leg, joint)) {
                    any_moving = true;
                    break;
                }
            }
            std::cout << std::setw(12) << (any_moving ? "YES" : "NO") << std::endl;
        }
        std::cout << "---------------------------------------------------------------" << std::endl;
        std::cout << "Total servo commands received: " << angle_history_.size() << std::endl;
    }
};

/**
 * @brief Prints the test header
 */
static void printTestHeader() {
    std::cout << "===============================================================================" << std::endl;
    std::cout << "                        VIRTUAL HARDWARE SIMULATION TEST" << std::endl;
    std::cout << "===============================================================================" << std::endl;
    std::cout << "This test simulates virtual hardware interfaces and visualizes servo angle" << std::endl;
    std::cout << "commands generated by the HexaMotion locomotion system during tripod gait." << std::endl;
    std::cout << "Velocity: " << TEST_VELOCITY << " mm/s" << std::endl;
    std::cout << "Duration: " << VISUALIZATION_STEPS << " simulation steps" << std::endl;
    std::cout << "Output: Real-time angle updates + final report file" << std::endl;
    std::cout << "===============================================================================\n"
              << std::endl;
}

int main() {
    printTestHeader();

    // 1. Initialize the system with custom visualization interfaces
    Parameters params = createDefaultParameters();
    LocomotionSystem sys(params);

    VisualizationIMU imu;
    VisualizationFSR fsr;
    AngleVisualizationServo servos;

    BodyPoseConfiguration pose_config = getDefaultBodyPoseConfig(params);

    std::cout << "Initializing HexaMotion system with visualization interfaces..." << std::endl;
    if (!sys.initialize(&imu, &fsr, &servos, pose_config)) {
        std::cerr << "ERROR: Failed to initialize locomotion system." << std::endl;
        return 1;
    }

    // 2. Set standing pose and show initial angles
    std::cout << "\nSetting initial standing pose..." << std::endl;
    if (!sys.setStandingPose()) {
        std::cerr << "ERROR: Failed to set standing pose." << std::endl;
        return 1;
    }

    servos.printCurrentAngles();

    // 3. Start tripod gait (new API)
    std::cout << "Starting tripod gait..." << std::endl;
    if (!sys.setGaitType(TRIPOD_GAIT)) {
        std::cerr << "ERROR: Failed to set gait type." << std::endl;
        return 1;
    }
    sys.walkForward(TEST_VELOCITY);
    if (!sys.startWalking()) {
        std::cerr << "ERROR: Failed to start walking (startup sequence)." << std::endl;
        return 1;
    }

    // 4. Execute startup sequence
    std::cout << "Executing startup sequence..." << std::endl;
    int startup_attempts = 0;
    const int MAX_STARTUP_ATTEMPTS = 50;

    while (sys.isStartupInProgress() && startup_attempts < MAX_STARTUP_ATTEMPTS) {
        servos.updateStep(startup_attempts);
        if (sys.executeStartupSequence()) {
            std::cout << "âœ… Startup sequence completed after " << startup_attempts << " attempts." << std::endl;
            break;
        }
        startup_attempts++;
    }

    if (startup_attempts >= MAX_STARTUP_ATTEMPTS) {
        std::cerr << "ERROR: Startup sequence failed to complete." << std::endl;
        return 1;
    }

    // 5. Main visualization loop
    std::cout << "\nðŸ”¥ Starting servo angle visualization..." << std::endl;
    std::cout << "Detailed leg states every 20 steps:\n"
              << std::endl;

    for (int step = 0; step < VISUALIZATION_STEPS; step++) {
        servos.updateStep(step);

        // Simulate terrain variations
        imu.simulateTerrainTilt(step);

        // Update the locomotion system
        if (!sys.update()) {
            std::cerr << "Warning: System update failed at step " << step << std::endl;
            continue;
        }

        // Show detailed servo angles every 18 steps
        if (step % 18 == 0) {
            std::cout << "\n--- Step " << step << " Servo Visualization ---" << std::endl;
            servos.printServoVisualization(step);
            std::cout << "Total servo commands issued: " << servos.getAngleHistorySize() << std::endl;
            std::cout << std::endl;
        }

        // Small delay to make visualization readable
        if (step % 5 == 0) {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }

    // 6. Show final results
    std::cout << "\nðŸŽ¯ VISUALIZATION COMPLETE!" << std::endl;
    servos.printCurrentAngles();

    // 7. Stop walking and return to standing
    std::cout << "Stopping walk and returning to standing pose..." << std::endl;
    if (!sys.stopWalking()) {
        std::cerr << "Warning: Failed to stop walking." << std::endl;
    }

    // Execute shutdown sequence
    int shutdown_attempts = 0;
    const int MAX_SHUTDOWN_ATTEMPTS = 50;

    while (sys.isShutdownInProgress() && shutdown_attempts < MAX_SHUTDOWN_ATTEMPTS) {
        servos.updateStep(VISUALIZATION_STEPS + shutdown_attempts);
        if (sys.executeShutdownSequence()) {
            std::cout << "âœ… Shutdown sequence completed." << std::endl;
            break;
        }
        shutdown_attempts++;
    }

    // 8. Generate final report
    std::cout << "\nGenerating final angle report..." << std::endl;
    servos.generateAngleReport();
    servos.printCurrentAngles();

    // 9. Final validation
    std::cout << "\n=== FINAL TEST SUMMARY ===" << std::endl;
    std::cout << "âœ… Total simulation steps: " << VISUALIZATION_STEPS << std::endl;
    std::cout << "âœ… Total servo commands captured: " << servos.getAngleHistorySize() << std::endl;
    std::cout << "âœ… HexaMotion angle generation successfully visualized" << std::endl;
    std::cout << "âœ… Report saved to: hexamotion_angle_report.txt" << std::endl;

    // 10. SYNCHRONIZATION VERIFICATION WITH tripod_walk_visualization_test.cpp
    std::cout << "\n=== SYNCHRONIZATION VERIFICATION ===" << std::endl;
    std::cout << "ðŸ“‹ ANGLE UNIT CONSISTENCY CHECK:" << std::endl;
    std::cout << "  âœ… virtual_hardware_sim_test: Captures angles from IServoInterface (already in degrees)" << std::endl;
    std::cout << "  âœ… tripod_walk_visualization_test: Reads angles from Leg objects (radians â†’ degrees conversion)" << std::endl;
    std::cout << "  âœ… Both tests now use the same RADIANS_TO_DEGREES_FACTOR = (180.0 / M_PI)" << std::endl;
    std::cout << "  âœ… Conversion path: leg.getJointAngles() [radians] â†’ LocomotionSystem::setLegJointAngles() â†’ servo interface [degrees]" << std::endl;

    std::cout << "\nðŸ”„ TRAJECTORY TIMING SYNCHRONIZATION:" << std::endl;
    std::cout << "  âœ… Both tests use identical LocomotionSystem configuration" << std::endl;
    std::cout << "  âœ… Both tests execute the same WalkController â†’ LegStepper trajectory sequence" << std::endl;
    std::cout << "  âœ… Both tests use the same StepCycle timing (52 iterations per phase)" << std::endl;
    std::cout << "  âœ… Both tests call sys.update() with identical frequency" << std::endl;

    std::cout << "\nðŸŽ¯ EXPECTED RESULT:" << std::endl;
    std::cout << "  âœ… Angle values from virtual_hardware_sim_test should now match tripod_walk_visualization_test" << std::endl;
    std::cout << "  âœ… Both tests visualize the SAME underlying joint angle trajectory" << std::endl;
    std::cout << "  âœ… Differences in previous runs were due to angle unit handling discrepancies" << std::endl;

    std::cout << "\nðŸŽ‰ SERVO ANGLE VISUALIZATION TEST PASSED! ðŸŽ‰" << std::endl;
    std::cout << "The HexaMotion system generated " << servos.getAngleHistorySize()
              << " servo angle commands during " << VISUALIZATION_STEPS << " simulation steps." << std::endl;

    return 0;
}
