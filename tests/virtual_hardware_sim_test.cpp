/**
 * @file virtual_hardware_sim_test.cpp
 * @brief Test to simulate virtual hardware interfaces with HexaMotion system.
 *
 * This test implements custom interface implementations that simulate virtual
 * hardware and visualize the servo angles generated by the HexaMotion locomotion
 * system during a tripod gait. The test provides detailed visualization of:
 * 1. Joint angles for each leg (coxa, femur, tibia) in degrees
 * 2. Angular velocities and speeds
 * 3. Movement progression over time
 * 4. Virtual hardware behavior simulation
 *
 * IMPORTANT NOTE ABOUT ANGLE UNITS:
 * This test captures angles through the IServoInterface, where angles arrive
 * already converted to DEGREES by LocomotionSystem::setLegJointAngles().
 * This is different from tripod_walk_visualization_test.cpp which reads angles
 * directly from Leg objects (in radians) and converts them to degrees for display.
 * Both tests should show identical angle values when executed correctly.
 *
 * The test uses:
 * - VisualizationIMU: Virtual IMU implementation for stable orientation
 * - VisualizationFSR: Virtual FSR implementation for ground contact simulation
 * - AngleVisualizationServo: Virtual servo interface that captures and displays angles
 *
 * @author HexaMotion Team
 * @version 1.0
 * @date 2025
 */

#include "../src/body_pose_config_factory.h"
#include "../src/gait_config_factory.h"
#include "../src/locomotion_system.h"
#include "robot_model.h"
#include "test_stubs.h"
#include <cassert>
#include <chrono>
#include <cmath>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <thread>
#include <vector>

// Test configuration (synchronized with tripod_walk_visualization_test where applicable)
constexpr double TEST_VELOCITY = 100.0;        // mm/s forward velocity (matches tripod test)
constexpr double TEST_ANGULAR_VELOCITY = 0.25; // rad/s angular component (added for richer motion)
constexpr int VISUALIZATION_STEPS = 150;       // Steps to run the visualization
constexpr int ANGLE_HISTORY_SIZE = 200;        // Number of angle measurements to store

// CLI flags
static const char *FLAG_ENABLE_FSR = "--fsr";                        // Enable FSR-based contact adaptation
static const char *FLAG_CONTACT_THRESHOLD = "--contact-th=";         // (Deprecated) Override contact threshold (alias for fsr touchdown)
static const char *FLAG_FSR_TOUCHDOWN_THRESHOLD = "--fsr-touch-th="; // Override fsr touchdown threshold (0-1)
static const char *FLAG_RELEASE_THRESHOLD = "--release-th=";         // (Deprecated) Override release threshold (alias liftoff)
static const char *FLAG_FSR_LIFTOFF_THRESHOLD = "--fsr-liftoff-th="; // Override FSR liftoff threshold (0-1)
static const char *FLAG_MIN_PRESSURE = "--min-pressure=";            // (Deprecated) Override minimum pressure (alias)
static const char *FLAG_FSR_MIN_PRESSURE = "--fsr-min-pressure=";    // Override minimum normalized FSR pressure (0-1)
static const char *FLAG_PRESERVE_SWING = "--preserve-swing";         // Preserve swing end pose as stance origin
static const char *FLAG_NO_PRESERVE_SWING = "--no-preserve-swing";   // Reset stance origin each stance
static const char *FLAG_HELP = "--help";                             // Help flag
static const char *FLAG_DEBUG_FSR = "--debug-fsr";                   // Enable FSR phase transition logging
static const char *FLAG_DRIFT_METRICS = "--drift-metrics";           // Enable drift metrics accumulation & summary

/**
 * @brief Custom IMU interface for visualization that provides stable orientation data
 */
class VisualizationIMU : public IIMUInterface {
  private:
    double roll_ = 0.0;
    double pitch_ = 0.0;
    double yaw_ = 0.0;
    IMUMode current_mode_ = IMU_MODE_RAW_DATA;
    bool has_absolute_ = true;
    int update_count_ = 0;

  public:
    bool initialize() override {
        std::cout << "VisualizationIMU: Initialized with absolute positioning enabled" << std::endl;
        return true;
    }

    IMUData readIMU() override {
        IMUData data{};
        data.roll = roll_;
        data.pitch = pitch_;
        data.yaw = yaw_;
        data.accel_x = 0.0f;
        data.accel_y = 0.0f;
        data.accel_z = 9.81f;
        data.gyro_x = 0.0f;
        data.gyro_y = 0.0f;
        data.gyro_z = 0.0f;
        data.is_valid = true;
        data.mode = current_mode_;
        data.has_absolute_capability = has_absolute_;

        if (has_absolute_) {
            data.absolute_data.absolute_roll = roll_;
            data.absolute_data.absolute_pitch = pitch_;
            data.absolute_data.absolute_yaw = yaw_;
            data.absolute_data.linear_accel_x = 0.0f;
            data.absolute_data.linear_accel_y = 0.0f;
            data.absolute_data.linear_accel_z = 0.0f;
            data.absolute_data.quaternion_w = 1.0f;
            data.absolute_data.quaternion_x = 0.0f;
            data.absolute_data.quaternion_y = 0.0f;
            data.absolute_data.quaternion_z = 0.0f;
            data.absolute_data.absolute_orientation_valid = true;
            data.absolute_data.linear_acceleration_valid = true;
            data.absolute_data.quaternion_valid = true;
            data.absolute_data.calibration_status = 3;
            data.absolute_data.system_status = 5;
            data.absolute_data.self_test_result = 0x0F;
        }

        return data;
    }

    bool calibrate() override { return true; }
    bool isConnected() override { return true; }
    bool setIMUMode(IMUMode mode) override {
        current_mode_ = mode;
        return true;
    }
    IMUMode getIMUMode() const override { return current_mode_; }
    bool hasAbsolutePositioning() const override { return has_absolute_; }
    bool getCalibrationStatus(uint8_t *system, uint8_t *gyro, uint8_t *accel, uint8_t *mag) override {
        if (system)
            *system = 3;
        if (gyro)
            *gyro = 3;
        if (accel)
            *accel = 3;
        if (mag)
            *mag = 3;
        return true;
    }
    bool runSelfTest() override { return true; }
    bool resetOrientation() override { return true; }
    bool update() override {
        update_count_++;
        return true;
    }

    // Add slight terrain simulation
    void simulateTerrainTilt(int step) {
        // Simulate gentle terrain variations
        double terrain_freq = 0.02;
        roll_ = math_utils::degreesToRadians(2.0 * sin(step * terrain_freq));        // ±2 degrees
        pitch_ = math_utils::degreesToRadians(1.5 * cos(step * terrain_freq * 1.3)); // ±1.5 degrees
    }
};

/**
 * @brief Custom FSR interface for visualization with realistic ground contact simulation
 */
class VisualizationFSR : public IFSRInterface {
  private:
    FSRData test_data_[NUM_LEGS];
    int update_count_ = 0;

  public:
    VisualizationFSR() {
        for (int i = 0; i < NUM_LEGS; i++) {
            test_data_[i] = FSRData{3.0f, true, 0.0f}; // Start with ground contact
        }
        std::cout << "VisualizationFSR: Initialized with all legs in contact" << std::endl;
    }

    bool initialize() override { return true; }

    FSRData readFSR(int leg) override {
        if (leg >= 0 && leg < NUM_LEGS) {
            return test_data_[leg];
        }
        return FSRData{0.0f, false, 0.0f};
    }

    bool calibrateFSR(int) override { return true; }

    double getRawReading(int leg) override {
        if (leg >= 0 && leg < NUM_LEGS) {
            return test_data_[leg].pressure;
        }
        return 0.0f;
    }

    bool update() override {
        update_count_++;
        // Simulate realistic pressure variations during walking
        for (int i = 0; i < NUM_LEGS; i++) {
            if (test_data_[i].in_contact) {
                // Add slight pressure variations for legs in contact
                test_data_[i].pressure = 3.0f + 0.5f * sin(update_count_ * 0.1 + i);
            }
        }
        return true;
    }

    // Simulate leg lifting and touchdown for gait visualization
    void simulateGaitContact(int leg, bool in_contact) {
        if (leg >= 0 && leg < NUM_LEGS) {
            test_data_[leg].in_contact = in_contact;
            test_data_[leg].pressure = in_contact ? 3.5f : 0.1f;
        }
    }
};

/**
 * @brief Servo angle data structure for storing angle history
 */
struct ServoAngleRecord {
    int step;
    int leg;
    int joint;
    double angle_degrees;
    double speed;
    double acceleration;
    double target_angle_degrees;
    std::chrono::steady_clock::time_point timestamp;
};

/**
 * @brief Custom servo interface that captures and visualizes all angle commands
 */
class AngleVisualizationServo : public IServoInterface {
  private:
    double current_angles_[NUM_LEGS][3]; // [leg][joint]
    double target_angles_[NUM_LEGS][3];  // [leg][joint]
    double speeds_[NUM_LEGS][3];         // [leg][joint]
    bool torque_enabled_[NUM_LEGS][3];   // [leg][joint]
    std::vector<ServoAngleRecord> angle_history_;
    int current_step_ = 0;

    const char *joint_names_[3] = {"Coxa", "Femur", "Tibia"};

  public:
    AngleVisualizationServo() {
        // Initialize with neutral standing positions
        // NOTE: These initial values are in RADIANS for internal consistency with the robot model,
        // but setJointAngleAndSpeed() will receive angles already converted to DEGREES by LocomotionSystem
        for (int leg = 0; leg < NUM_LEGS; leg++) {
            current_angles_[leg][0] = 0.0;  // Coxa neutral (will be overwritten by degree values from servo commands)
            current_angles_[leg][1] = -35;  // Femur ~23 degrees (corrected to degrees for servo interface consistency)
            current_angles_[leg][2] = 35.0; // Tibia ~-57 degrees (corrected to degrees for servo interface consistency)

            for (int joint = 0; joint < 3; joint++) {
                target_angles_[leg][joint] = current_angles_[leg][joint];
                speeds_[leg][joint] = 1.0;
                torque_enabled_[leg][joint] = true;
            }
        }
        angle_history_.reserve(ANGLE_HISTORY_SIZE * NUM_LEGS * 3);
        std::cout << "AngleVisualizationServo: Initialized with neutral standing angles (in degrees)" << std::endl;
    }

    bool initialize() override {
        std::cout << "AngleVisualizationServo: Hardware interface initialized" << std::endl;
        return true;
    }

    bool hasBlockingStatusFlags(int leg, int joint) override {
        // No blocking flags for visualization
        return false;
    }

    bool setJointAngleAndSpeed(int leg, int joint, double angle, double speed) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            // Store previous angle for comparison
            double prev_angle = target_angles_[leg][joint];

            // Update target angle and speed
            // NOTE: The 'angle' parameter arrives already converted to DEGREES by LocomotionSystem::setLegJointAngles()
            // which applies: servo_angle = math_utils::radiansToDegrees(joint_angle_radians * params.angle_sign_*)
            target_angles_[leg][joint] = angle;
            speeds_[leg][joint] = speed;

            // Simulate servo movement towards target (with some smoothing)
            double diff = angle - current_angles_[leg][joint];
            double movement_rate = 0.3 * speed; // Adjust movement rate based on speed
            movement_rate = std::max(0.1, std::min(1.0, movement_rate));
            current_angles_[leg][joint] += diff * movement_rate;

            // Record this angle command
            ServoAngleRecord record;
            record.step = current_step_;
            record.leg = leg;
            record.joint = joint;
            record.angle_degrees = angle; // Already in degrees
            record.speed = speed;
            record.acceleration = 0.0;           // legacy call (no acceleration provided)
            record.target_angle_degrees = angle; // Already in degrees
            record.timestamp = std::chrono::steady_clock::now();

            angle_history_.push_back(record);

            return true;
        }
        return false;
    }

    bool setJointAngleSpeedAccel(int leg, int joint, double angle, double speed, double acceleration) override {
        if (setJointAngleAndSpeed(leg, joint, angle, speed)) {
            // Patch last record with acceleration value (since setJointAngleAndSpeed already pushed it)
            if (!angle_history_.empty()) {
                angle_history_.back().acceleration = acceleration;
            }
            return true;
        }
        return false;
    }

    double getJointAngle(int leg, int joint) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            // Return current simulated position with small noise
            return current_angles_[leg][joint] + (rand() % 100 - 50) * 0.001;
        }
        return 0.0;
    }

    bool isJointMoving(int leg, int joint) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            // Consider joint moving if difference between current and target is significant
            return std::abs(target_angles_[leg][joint] - current_angles_[leg][joint]) > 0.02;
        }
        return false;
    }

    bool enableTorque(int leg, int joint, bool enable) override {
        if (leg >= 0 && leg < NUM_LEGS && joint >= 0 && joint < 3) {
            torque_enabled_[leg][joint] = enable;
            return true;
        }
        return false;
    }

    // Visualization methods
    void updateStep(int step) {
        current_step_ = step;
    }

    void printCurrentAngles() {
        std::cout << "\n=== CURRENT SERVO ANGLES ===" << std::endl;
        std::cout << std::left << std::setw(6) << "Leg"
                  << std::setw(12) << "Coxa (°)"
                  << std::setw(12) << "Femur (°)"
                  << std::setw(12) << "Tibia (°)"
                  << std::setw(12) << "Moving?" << std::endl;
        std::cout << "---------------------------------------------------------------" << std::endl;

        for (int leg = 0; leg < NUM_LEGS; leg++) {
            std::cout << std::fixed << std::setprecision(2);
            std::cout << std::left << std::setw(6) << ("L" + std::to_string(leg + 1));

            for (int joint = 0; joint < 3; joint++) {
                std::cout << std::setw(12) << current_angles_[leg][joint];
            }

            // Check if any joint is moving
            bool any_moving = false;
            for (int joint = 0; joint < 3; joint++) {
                if (isJointMoving(leg, joint)) {
                    any_moving = true;
                    break;
                }
            }
            std::cout << std::setw(12) << (any_moving ? "YES" : "NO") << std::endl;
        }
        std::cout << "---------------------------------------------------------------\n"
                  << std::endl;
    }

    void generateAngleReport() const {
        std::ofstream report("hexamotion_angle_report.txt");
        if (!report.is_open()) {
            std::cerr << "Warning: Could not create angle report file" << std::endl;
            return;
        }

        report << "HexaMotion Servo Angle Visualization Report\n";
        report << "==========================================\n\n";

        report << "Test Configuration:\n";
        report << "- Velocity: " << TEST_VELOCITY << " mm/s\n";
        report << "- Total Steps: " << current_step_ << "\n";
        report << "- Total Angle Commands: " << angle_history_.size() << "\n\n";

        report << "Final Servo Positions:\n";
        for (int leg = 0; leg < NUM_LEGS; leg++) {
            report << "Leg " << (leg + 1) << ": ";
            for (int joint = 0; joint < 3; joint++) {
                report << joint_names_[joint] << "="
                       << std::fixed << std::setprecision(2)
                       << current_angles_[leg][joint] << "° ";
            }
            report << "\n";
        }

        report << "\nComplete Angle Command History:\n";
        report << "Step\tLeg\tJoint\tAngle(°)\tSpeed\n";
        for (const auto &record : angle_history_) {
            report << record.step << "\t"
                   << (record.leg + 1) << "\t"
                   << joint_names_[record.joint] << "\t"
                   << std::fixed << std::setprecision(2) << record.target_angle_degrees << "\t"
                   << record.speed << "\n";
        }

        report.close();
        std::cout << "Angle report saved to: hexamotion_angle_report.txt" << std::endl;
    }

    size_t getAngleHistorySize() const { return angle_history_.size(); }

    // Visualize servo angles purely from hardware interface data
    void printServoVisualization(int step) {
        std::cout << "\n=== SERVO ANGLES VISUALIZATION (Step " << step << ") ===" << std::endl;
        std::cout << std::left << std::setw(8) << "Leg"
                  << std::setw(12) << "Coxa (°)"
                  << std::setw(12) << "Femur (°)"
                  << std::setw(12) << "Tibia (°)"
                  << std::setw(12) << "Moving?" << std::endl;
        std::cout << "---------------------------------------------------------------" << std::endl;

        for (int leg = 0; leg < NUM_LEGS; leg++) {
            std::cout << std::fixed << std::setprecision(2);
            std::cout << std::left << std::setw(8) << ("Leg " + std::to_string(leg + 1));

            // Show target angles (what HexaMotion is commanding)
            // NOTE: These angles are already in degrees as received from LocomotionSystem::setLegJointAngles()
            // which converts from radians to degrees using math_utils::radiansToDegrees before sending to servo interface
            for (int joint = 0; joint < 3; joint++) {
                std::cout << std::setw(12) << target_angles_[leg][joint];
            }

            // Check if any joint is moving
            bool any_moving = false;
            for (int joint = 0; joint < 3; joint++) {
                if (isJointMoving(leg, joint)) {
                    any_moving = true;
                    break;
                }
            }
            std::cout << std::setw(12) << (any_moving ? "YES" : "NO") << std::endl;
        }
        std::cout << "---------------------------------------------------------------" << std::endl;
        std::cout << "Total servo commands received: " << angle_history_.size() << std::endl;
    }
};

/**
 * @brief Prints the test header
 */
static void printTestHeader() {
    std::cout << "===============================================================================" << std::endl;
    std::cout << "                        VIRTUAL HARDWARE SIMULATION TEST" << std::endl;
    std::cout << "===============================================================================" << std::endl;
    std::cout << "This test simulates virtual hardware interfaces and visualizes servo angle" << std::endl;
    std::cout << "commands generated by the HexaMotion locomotion system during tripod gait." << std::endl;
    std::cout << "Velocity: " << TEST_VELOCITY << " mm/s" << std::endl;
    std::cout << "Duration: " << VISUALIZATION_STEPS << " simulation steps" << std::endl;
    std::cout << "Output: Real-time angle updates + final report file" << std::endl;
    std::cout << "===============================================================================\n"
              << std::endl;
}

// Simple helper to parse double values from prefixed flags
static bool parseFlagValue(const std::string &arg, const char *prefix, double &out_val) {
    size_t len = std::strlen(prefix);
    if (arg.rfind(prefix, 0) == 0) {
        try {
            out_val = std::stod(arg.substr(len));
            return true;
        } catch (...) {
            return false;
        }
    }
    return false;
}

static void printHelp() {
    std::cout << "Usage: virtual_hardware_sim_test [options]\n"
              << "Options:\n"
              << "  " << FLAG_ENABLE_FSR << "            Enable FSR contact adaptation logic\n"
              << "  " << FLAG_CONTACT_THRESHOLD << "X   (Deprecated) Set contact threshold (alias, default 0.7)\n"
              << "  " << FLAG_FSR_TOUCHDOWN_THRESHOLD << "X   Set FSR touchdown threshold (0-1, default 0.7)\n"
              << "  " << FLAG_RELEASE_THRESHOLD << "X   (Deprecated) Set release threshold (alias, default 0.3)\n"
              << "  " << FLAG_FSR_LIFTOFF_THRESHOLD << "X   Set FSR liftoff threshold (0-1, default 0.3)\n"
              << "  " << FLAG_MIN_PRESSURE << "X       (Deprecated) Set min pressure (legacy raw, alias)\n"
              << "  " << FLAG_FSR_MIN_PRESSURE << "X   Set min normalized FSR pressure (0-1, default 0.05)\n"
              << "  " << FLAG_PRESERVE_SWING << "          Preserve swing touchdown as stance origin (continuous)\n"
              << "  " << FLAG_NO_PRESERVE_SWING << "      Reset stance origin each cycle (anti-drift)\n"
              << "  " << FLAG_DEBUG_FSR << "            Log FSR phase transitions\n"
              << "  " << FLAG_DRIFT_METRICS << "       Accumulate & report drift metrics\n"
              << "  " << FLAG_HELP << "                 Show this help message\n"
              << std::endl;
}

int main(int argc, char **argv) {
    printTestHeader();

    // 1. Initialize the system with custom visualization interfaces
    Parameters params = createDefaultParameters();
    bool enable_fsr = true;
    bool debug_fsr = false;
    bool preserve_flag_set = false;
    bool drift_metrics = false; // still controls printing summary, metrics always collected in TESTING builds

    // Parse CLI flags
    for (int i = 1; i < argc; ++i) {
        std::string arg(argv[i]);
        if (arg == FLAG_HELP) {
            printHelp();
            return 0;
        } else if (arg == FLAG_ENABLE_FSR) {
            enable_fsr = true;
        } else if (arg == "--debug-drift") { /* deprecated flag ignored */
        } else if (arg == FLAG_DEBUG_FSR) {
            debug_fsr = true;
        } else if (arg == FLAG_DRIFT_METRICS) {
            drift_metrics = true; // only affects final report visibility
        } else if (arg == FLAG_PRESERVE_SWING) {
            params.preserve_swing_end_pose = true;
            preserve_flag_set = true;
        } else if (arg == FLAG_NO_PRESERVE_SWING) {
            params.preserve_swing_end_pose = false;
            preserve_flag_set = true;
        } else if (!parseFlagValue(arg, FLAG_FSR_TOUCHDOWN_THRESHOLD, params.fsr_touchdown_threshold) &&
                   !parseFlagValue(arg, FLAG_CONTACT_THRESHOLD, params.fsr_touchdown_threshold) &&
                   !parseFlagValue(arg, FLAG_FSR_LIFTOFF_THRESHOLD, params.fsr_liftoff_threshold) &&
                   !parseFlagValue(arg, FLAG_RELEASE_THRESHOLD, params.fsr_liftoff_threshold) &&
                   !parseFlagValue(arg, FLAG_FSR_MIN_PRESSURE, params.fsr_min_pressure) &&
                   !parseFlagValue(arg, FLAG_MIN_PRESSURE, params.fsr_min_pressure)) {
            std::cout << "Unknown argument: " << arg << " (ignored)" << std::endl;
        }
    }

    if (enable_fsr) {
        params.use_fsr_contact = true;
        // If default thresholds were not overridden they remain at struct defaults
        std::cout << "[FSR] Enabled with thresholds: touchdown=" << params.fsr_touchdown_threshold
                  << " liftoff=" << params.fsr_liftoff_threshold
                  << " fsr_min_pressure=" << params.fsr_min_pressure << std::endl;
    } else {
        std::cout << "[FSR] Disabled (use " << FLAG_ENABLE_FSR << " to enable)." << std::endl;
    }
    params.debug_fsr_transitions = debug_fsr;
    // enable_drift_metrics removed; metrics gathered unconditionally under TESTING_ENABLED
    if (preserve_flag_set) {
        std::cout << "[Gait Continuity] preserve_swing_end_pose=" << (params.preserve_swing_end_pose ? "true" : "false")
                  /* drift debug removed */
                  << " debug_fsr=" << (params.debug_fsr_transitions ? "on" : "off") << std::endl;
    } else {
        std::cout << "[Gait Continuity] Using default preserve_swing_end_pose=" << (params.preserve_swing_end_pose ? "true" : "false")
                  /* drift debug removed */
                  << " debug_fsr=" << (params.debug_fsr_transitions ? "on" : "off")
                  << " (override with " << FLAG_PRESERVE_SWING << " or " << FLAG_NO_PRESERVE_SWING << ")" << std::endl;
    }
    LocomotionSystem sys(params);

    VisualizationIMU imu;
    VisualizationFSR fsr;
    AngleVisualizationServo servos;

    BodyPoseConfiguration pose_config = getDefaultBodyPoseConfig(params);

    std::cout << "Initializing HexaMotion system with visualization interfaces..." << std::endl;
    if (!sys.initialize(&imu, &fsr, &servos, pose_config)) {
        std::cerr << "ERROR: Failed to initialize locomotion system." << std::endl;
        return 1;
    }

    // 2. Set standing pose and show initial angles
    std::cout << "\nSetting initial standing pose..." << std::endl;
    if (!sys.setStandingPose()) {
        std::cerr << "ERROR: Failed to set standing pose." << std::endl;
        return 1;
    }

    servos.printCurrentAngles();

    // 3. Start tripod gait (new API)
    std::cout << "Starting tripod gait..." << std::endl;
    if (!sys.setGaitType(TRIPOD_GAIT)) {
        std::cerr << "ERROR: Failed to set gait type." << std::endl;
        return 1;
    }
    sys.walkForward(TEST_VELOCITY);
    // Add angular component similar to tripod visualization test
    if (TEST_ANGULAR_VELOCITY != 0.0) {
        sys.turnInPlace(TEST_ANGULAR_VELOCITY); // persistent angular velocity (combined with forward)
    }
    if (!sys.startWalking()) {
        std::cerr << "ERROR: Failed to start walking (startup sequence)." << std::endl;
        return 1;
    }

    // 4. Execute startup sequence
    std::cout << "Executing startup sequence..." << std::endl;
    int startup_attempts = 0;
    // Estimate iterations for two-phase startup matching BodyPoseController timing
    const Parameters &startup_params = sys.getParameters();
    double time_delta_startup = startup_params.time_delta;
    double step_frequency_startup = startup_params.step_frequency;
    int horiz_iters = std::max(1, (int)std::round((1.0 / step_frequency_startup) / time_delta_startup));
    int vert_iters = std::max(1, (int)std::round((3.0 / step_frequency_startup) / time_delta_startup));
    int expected_total_iters = horiz_iters + vert_iters;
    const int MAX_STARTUP_ATTEMPTS = expected_total_iters + 80; // margin
    std::cout << "Estimated startup iterations (horizontal=" << horiz_iters << ", vertical=" << vert_iters
              << ", total=" << expected_total_iters << ")  Max attempts=" << MAX_STARTUP_ATTEMPTS << std::endl;

    while (sys.isStartupInProgress() && startup_attempts < MAX_STARTUP_ATTEMPTS) {
        servos.updateStep(startup_attempts);
        if (sys.executeStartupSequence()) {
            std::cout << "✅ Startup sequence completed after " << startup_attempts << " attempts." << std::endl;
            break;
        }
        if (startup_attempts % 25 == 0) {
            std::cout << "Startup attempt " << startup_attempts << " Progress=" << sys.getStartupProgressPercent() << "%" << std::endl;
        }
        startup_attempts++;
    }

    if (startup_attempts >= MAX_STARTUP_ATTEMPTS) {
        std::cerr << "ERROR: Startup sequence failed to complete." << std::endl;
        return 1;
    }

    // 5. Main visualization loop
    std::cout << "\n🔥 Starting servo angle visualization..." << std::endl;
    std::cout << "Detailed leg states every 20 steps:\n"
              << std::endl;

    for (int step = 0; step < VISUALIZATION_STEPS; step++) {
        servos.updateStep(step);

        // Simulate terrain variations
        imu.simulateTerrainTilt(step);

        // FSR contact simulation (if enabled): mimic liftoff first half swing, touchdown second half
        if (enable_fsr) {
            WalkController *wc = sys.getWalkController();
            if (wc) {
                for (int leg = 0; leg < NUM_LEGS; ++leg) {
                    auto stepper = wc->getLegStepper(leg);
                    if (stepper) {
                        if (stepper->getStepState() == STEP_SWING) {
                            double swing_prog = stepper->getStepProgress();
                            bool contact = (swing_prog >= 0.55); // touchdown slightly after mid-swing
                            fsr.simulateGaitContact(leg, contact);
                        } else {
                            fsr.simulateGaitContact(leg, true); // stance = contact
                        }
                    }
                }
            }
        }

        // Update the locomotion system
        if (!sys.update()) {
            std::cerr << "Warning: System update failed at step " << step << std::endl;
            continue;
        }

        // Show detailed servo angles every 18 steps
        if (step % 18 == 0) {
            std::cout << "\n--- Step " << step << " Servo Visualization ---" << std::endl;
            servos.printServoVisualization(step);
            std::cout << "Total servo commands issued: " << servos.getAngleHistorySize() << std::endl;
            std::cout << std::endl;
        }

        // Small delay to make visualization readable
        if (step % 5 == 0) {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }

    // 6. Show final results
    std::cout << "\n🎯 VISUALIZATION COMPLETE!" << std::endl;
    servos.printCurrentAngles();

    // 7. Stop walking and return to standing
    std::cout << "Stopping walk and returning to standing pose..." << std::endl;
    if (!sys.stopWalking()) {
        std::cerr << "Warning: Failed to stop walking." << std::endl;
    }

    // Execute shutdown sequence
    int shutdown_attempts = 0;
    const int MAX_SHUTDOWN_ATTEMPTS = 50;

    while (sys.isShutdownInProgress() && shutdown_attempts < MAX_SHUTDOWN_ATTEMPTS) {
        servos.updateStep(VISUALIZATION_STEPS + shutdown_attempts);
        if (sys.executeShutdownSequence()) {
            std::cout << "✅ Shutdown sequence completed." << std::endl;
            break;
        }
        shutdown_attempts++;
    }

    // 8. Generate final report
    std::cout << "\nGenerating final angle report..." << std::endl;
    servos.generateAngleReport();
    servos.printCurrentAngles();

    // 9. Final validation
    std::cout << "\n=== FINAL TEST SUMMARY ===" << std::endl;
    std::cout << "✅ Total simulation steps: " << VISUALIZATION_STEPS << std::endl;
    std::cout << "✅ Total servo commands captured: " << servos.getAngleHistorySize() << std::endl;
    std::cout << "✅ HexaMotion angle generation successfully visualized" << std::endl;
    std::cout << "✅ Report saved to: hexamotion_angle_report.txt" << std::endl;

    // 10. SYNCHRONIZATION VERIFICATION WITH tripod_walk_visualization_test.cpp
    std::cout << "\n=== SYNCHRONIZATION VERIFICATION ===" << std::endl;
    std::cout << "📋 ANGLE UNIT CONSISTENCY CHECK:" << std::endl;
    std::cout << "  ✅ virtual_hardware_sim_test: Captures angles from IServoInterface (already in degrees)" << std::endl;
    std::cout << "  ✅ tripod_walk_visualization_test: Reads angles from Leg objects (radians → degrees conversion)" << std::endl;
    std::cout << "  ✅ Both tests now use math_utils::radiansToDegrees for conversions" << std::endl;
    std::cout << "  ✅ Conversion path: leg.getJointAngles() [radians] → LocomotionSystem::setLegJointAngles() → servo interface [degrees]" << std::endl;

    std::cout << "\n🔄 TRAJECTORY TIMING SYNCHRONIZATION:" << std::endl;
    std::cout << "  ✅ Both tests use identical LocomotionSystem configuration" << std::endl;
    std::cout << "  ✅ Both tests execute the same WalkController → LegStepper trajectory sequence" << std::endl;
    std::cout << "  ✅ Both tests use the same StepCycle timing (iteraciones derivadas dinámicamente por fase)" << std::endl;
    std::cout << "  ✅ Both tests call sys.update() with identical frequency" << std::endl;

    std::cout << "\n🎯 EXPECTED RESULT:" << std::endl;
    std::cout << "  ✅ Angle values from virtual_hardware_sim_test should now match tripod_walk_visualization_test" << std::endl;
    std::cout << "  ✅ Both tests visualize the SAME underlying joint angle trajectory" << std::endl;
    std::cout << "  ✅ Differences in previous runs were due to angle unit handling discrepancies" << std::endl;

    std::cout << "\n🎉 SERVO ANGLE VISUALIZATION TEST PASSED! 🎉" << std::endl;
    std::cout << "The HexaMotion system generated " << servos.getAngleHistorySize()
              << " servo angle commands during " << VISUALIZATION_STEPS << " simulation steps." << std::endl;

    if (drift_metrics) {
        std::cout << "\n=== DRIFT METRICS SUMMARY ===" << std::endl;
        WalkController *wc = sys.getWalkController();
        if (wc) {
            for (int leg = 0; leg < NUM_LEGS; ++leg) {
                auto stepper = wc->getLegStepper(leg);
                if (stepper) {
                    auto vec = stepper->getAccumulatedDriftVector();
                    std::cout << "Leg " << leg
                              << ": last_offset_mm=" << stepper->getLastTouchdownOffsetNorm()
                              << " acc_mm=" << stepper->getAccumulatedDriftNorm()
                              << " ema_mm=" << stepper->getDriftEMANorm();
                    if (params.report_planar_vs_vertical_drift) {
                        std::cout << " planar_mm=" << stepper->getPlanarDriftNorm()
                                  << " z_mm=" << stepper->getVerticalDrift();
                    }
                    std::cout << " vec=(" << vec.x << "," << vec.y << "," << vec.z << ")" << std::endl;
                }
            }
        } else {
            std::cout << "WalkController not available for drift metrics." << std::endl;
        }
    }

    return 0;
}
